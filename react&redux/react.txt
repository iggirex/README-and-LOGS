REACT.JS

to install CLI React app maker:
    npm install -g create-react-app
to create app:
    create-react-app my-app
to start app run command in root dir:
        npm start
    --> Issues running npm start try:
        --> npm install -g npm@latest to update npm because it is sometimes buggy.
        --> rm -rf node_modules to remove the existing modules.
        --> npm install to re-install the project dependencies.

------------------------------------------------------------------------------------------------------------
React has different kinds of components:
------------------------------------------------------------------------------------------------------------
React.Component subclasses:
    --> The component tells React what to render

            class ShoppingList extends React.Component {
                render() {
                    return (
                    <div className="shopping-list">
                        <h1>Shopping List for {this.props.name}</h1>
                        <ul>
                        <li>Instagram</li>
                        <li>WhatsApp</li>
                        <li>Oculus</li>
                        </ul>
                    </div>
                    );
                }
                }

    --> here ShoppingList is a REACT COMPONENT CLASS (component type).
    --> components take in parameters called PROPS and returns a hierarchy of views to display via render()


    --> Most React devs use a special syntex called JSX, makes it easier to write these structures  

            return React.createElement('div', {className: 'shopping-list'},
                React.createElement('h1', /* ... h1 children ... */),
                React.createElement('ul', /* ... ul children ... */)
            );


When you want to aggregate data from multiple children or to have two child 
components communicate with each other, move the state upwards so that it lives in the parent component.

If component is does not have state, it doesn't need constructor



------------------------------------------------------------------------------
------------------------------------------------------------------------------
------------------------------------------------------------------------------

React is library that produces html for user to see
Uses components/views are snippets of code that produces HTML
React code is writing multiple different components 
nested together in diff fashions to make really complex apps really simple

COMPONENT - A collection of JS functions that produce HTML
        --> ALWAYS MAKE ONE COMPONENT PER FILE

BUNDLE.JS ---> Compiled Javascript, the entirety of a Reach application
                Compiled to JS that the browser can understand

Webpack + Babel grab all JS files in a project, 
put them into a single file and makes them available as undle.js


SIMPLEST RENDER TO PAGE INDEX.JS ===============================================

//Core React functionality in React Library
import React from 'react';
//DOM rendering functionality is diff library: ReactDOM
import ReactDOM from 'react-dom';


//Create a new component. This component should produce 

// const App = function(){
//     return <div>Hi!</div>;
// }
//We pass AN INSTANCE TO REACT DOM,
//not a class
const App = () => {
    return <div>Hi!</div>;
}


//JSX is this html-looking stuff, it's still JS
//the real html will not look exaclty like this

//Take this component's generated HTML and put it
//on the page (in the DOM)
// !!! THIS IS WRONG -- React library does not render to DOM
// React.render(App);

// Correct/, ReactDOM is the library that renders to the DOM
// ReactDOM.render(App)
//WRONG App is a class, classes do not get rendered

//Correct -- <App></App> is an instance of App class
// can be shortened to <App /> since theren's nothing inside
//ReactDOM.render(<App />);   // ERROR TARGET containeer is not a DOM element

const container = document.getElementsByClassName('container')
//Correct, add second argument to specify where to put jsx
ReactDOM.render(<App />, container[0]);
ReactDOM.render(<App />, document.querySelector('.container'));
===============================================================================

EXPORTING MODULES

    search_bar.js:
            //We aren't directly calling React here, but remember
            //JSX turns our html-looky stuff to React.createElement(blabla) !!!
            import React from 'react';

            const SearchBar = () => {
                return <input />; // no need to close input, nothing in it
            }
            // this is called FUNCTIONAL COMPONENT, function that shoots out JSX

            // how to give access to SearchBar from other files !!!
            export default SearchBar;

    index.js:
            //we don't specify PATH for libraries, they can't have dupe names
            import React from 'react';
            import ReactDOM from 'react-dom';

            //this is how we IMPORT COMPONENTS
            import SearchBar from './components/search_bar';
            //for FILES WE CREATE we have to include PATH, there could be many diff search_bar.js's

            const API_KEY = "AIzaSyBsX85XkZym24Kioz9iqQXmSG2ktLtTBdY";

            const App = () => {
                // return parens are optional
                return (
                    <div>
                        <SearchBar />
                    </div>
                );
            }
            ReactDOM.render(<App />, document.querySelector('.container'));
===============================================================================

CLASSES
    --> Class components (opposed to functional components) are used
    when we want some sort of record keeping, component is aware of itself

    search_bar.js:
            // import React from 'react';
            import React, { Component} from 'react';
            // we can handle importing React.Component by adding it to import
            // same as doing:
            // const Component = React.Component; curly braces say
            // import React and pull off Component as variable named Component


            // extends gives SearchBar class access to a bunch of functionality 
            //that React.component class has
            // class SearchBar extends React.Component{
                class SearchBar extends Component{
                //(syntax sugar)
                // since React.Component was already imported, can just say Component 


                //still needs to render itself somehow, so we define a
                // RENDER METHOD in the class, every REact class needs one
                render() {  // this acts like render: function() {}
                    return <input />;
                }
            }
            export default SearchBar;
    
    index.js: stays exactly the same
===============================================================================

EVENT HANDLER

        search_bar.js:
            import React, { Component} from 'react';

            class SearchBar extends Component {
                render() {
                    return <input onChange={this.onInputChange} />;
                    // to handle vanilla JS events, write on<name of event>={event handler}
                    // JSX as JS variables needs to be wrapped in curly braces
                    // onChange is a "property" or "prop" of the input element
                }
                //define another method as an event handler
                onInputChange(event) { //generally called 'handle' or 'on'
                    // all browser events pass down an "event" object
                    console.log(event.target.value)
                }
            }

            // above code can be shortened to:
            // return <input onChange={(event) => console.log(event.target.value)} />;
            export default SearchBar;
===============================================================================

STATE
--> state is a plain JS object used to record and react to user events
--each class based component has its own state object
---> whenever a component state is changed, the component re-renders and forces
all its children to re-render

        search_bar.js:
            import React, { Component} from 'react';

            class SearchBar extends Component {
                // ALL JS CLASSES have a special method called constructor
                // constructor function is first and only function called AUTOMATICALY whenever
                // a new instance of class is created
                // constructor does SETUP and INITIALIZES STATE
                constructor(props){
                    // "super" is how we access method of parent class Component
                    super(props);

                    // EACH INSTANCE OF SEARCHBAR CLASS WILL HAVE ITS OWN STATE
                    // this is only place where we'll use this.state =
                    // EVERYWHERE ELSE to change state we'll use "this.setState()"
                    this.state = { term: "" };
                }

                render() {
                    // setState takes an object that will be the new state
                    return(
                        <div>
                            <input onChange={(event) => this.setState({ term: event.target.value })} />
                            Value of input: {this.state.term}
                        </div>
                    );
                    //using this.state.term to REFERENCE, not change state
                    // whenever setState is called, componene is re-rendered, so updates this into DOM
                }
            }
            export default SearchBar;
===============================================================================

CONTROLLED COMPONENTS
    --->CONTROL FIELD is a FORM ELEMENT (like input) whose value is set by state, not other way around

            import React, { Component} from 'react';

            class SearchBar extends Component {
                constructor(props){
                    super(props);

                    this.state = { term: "" };
                }

                render() {
                    // when we add value to component, becomes CONTROLLED COMPONENT
                    // has its value set by state
                    return(
                        <div>
                            <input 
                            value = {this.state.term}
                            onChange={(event) => this.setState({ term: event.target.value })} />
                        </div>
                    );
                    // First thing that happens: index.js creates an instance of SearchBar
                    // Then constructor on SearchBar gives it a state of { term: ''}
                    // When someone types in input, setState changes state, but value of input is not yet changed
                    // we've only called event handler with new value
                    // Event handler runs, updating this.state.term to new value
                    // When setState is called our component immediately re-renders
                    // So when "render" is called again, input value receives updated this.state.term
                }
            }
            // deleting onChange will make input useless, can't type in it


            export default SearchBar;
===============================================================================

DOWNWARDS DATA FLOW
    --> All the React components (in their different files) need to know
    about the data coiming in from youtube API. Who makes the call? how is data shared?

    ---> Downwards data flow means that ONLY THE MOST PARENT COMPONENT should be
    responsible for fetching data. Be API, or Flux or Redux
===============================================================================
TURNING APP INTO CLASS COMPONENT AND ADDING STATE OF VIDEO SEARCH

            import React, { Component } from 'react';
            import ReactDOM from 'react-dom';
            import YTSearch from 'youtube-api-search';
            import SearchBar from './components/search_bar';
            const API_KEY = "AIzaSyBsX85XkZym24Kioz9iqQXmSG2ktLtTBdY";

            // We want to convert App from FUNCTIONAL component to CLASS component
            // const App = () => {
            //     return (
            //         <div>
            //             <SearchBar />
            //         </div>
            //     );
            // }
            // change const to class, add extends Component, (import Component up top)
            // and add render method, everything else should work the same
            // now we want to add YTSearch data to state of App, so make state in constructor
            class App extends Component {
                constructor(props) {
                    super(props)

                    // the state will contain the videos from YTSearch
                    this.state = { videos: [] };

                    //YTSearch will be updating, so its DATA CHANGING OVER TIME -> sounds like STATE
                    // Moving YTSearch into constructor so its part of our component state
                    YTSearch({key: API_KEY, term: "surfboards"}, (videos) => {
                        // this.setState({ videos: videos});
                        // ES6 syntax sugar, if an object has the same key and value name do this:
                        this.setState({ videos });
                    });
                }
                render() {
                    return (
                        <div>
                            <SearchBar />
                        </div>
                    );
                }
            }

            ReactDOM.render(<App />, document.querySelector('.container'));
===============================================================================

PASSING PROPS FROM PARENT COMPONENT

index.js

import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import YTSearch from 'youtube-api-search';
import SearchBar from './components/search_bar';
import VideoList from './components/video_list'
const API_KEY = "AIzaSyBsX85XkZym24Kioz9iqQXmSG2ktLtTBdY";

class App extends Component {
    constructor(props) {
        super(props)

        this.state = { videos: [] };

        YTSearch({key: API_KEY, term: "surfboards"}, (videos) => {
            this.setState({ videos });
        });
    }
    // imported VideoList up top, now we add it to App under SearchBar
    // VideoList needs access to YTSearch and this.state.videos to render vids list 
    // So we need to pass some data FROM PARENT COMPONENT APP TO CHILD COMPONENT VIDEOLIST
    // we do this by defining a property on the JSX tag (videos={this.state.videos})
    // THIS IS PASSING PROPS!!!!!!!!!!!!!
    render() {
        return (
            <div>
                <SearchBar />
                <VideoList videos={this.state.videos}/>
            </div>
        );
    }
}

ReactDOM.render(<App />, document.querySelector('.container'));



video_list.js

import React from 'react';

// This list is a DUMB LIST -- does not need state, it only shows stuff on App state
// When props are passed in from index.js, they arrive as an argument in the functional component
// arrives as 'props' //// BUT IF THIS WAS A CLASS, it would universally be available
// as this.props
const Videolist = (props) => {
    const videos = props.video;
    return (
        <ul className="col-md-4 list-group">
            {props.videos.length}
        </ul>
    );
};

export default Videolist;
===============================================================================
MAKING EACH VIDEO LIST ITEM COMPONENT AND RENDERING 


video_list.js

            import React from 'react';
            import VideoListItem from './video_list_item';

            // Now we want to loop through videos array, assign each video to "video_list_item" components
            // Build a loop NOT FOR LOOP (JS for loops are not great in general, 
            // instead use built in iterators like MAP)
            const Videolist = (props) => {

                // So we import the VideoListItem component, loop through the props coming in
                // create a new array 'videoItems' containing VideoListItem components to which
                // we pass the video data as props
                const videoItems = props.videos.map((video) => {
                    return <VideoListItem video={video} />
                });

                const videos = props.video;
                // Passing in videoItems in curly braces because it is a JSX variable
                // React is INTELLIGENT WHEN RENDERING ARRAYS OF ITEMS
                return (
                    <ul className="col-md-4 list-group">
                        {videoItems}
                    </ul>
                );
            };

export default Videolist;


            video_list_item.js

            import React from 'react';

            const VideoListItem = (props) => {
                return <li>Video</li>
            }

            export default VideoListItem;
===============================================================================
PROVIDING KEYS FOR COMPONENTS

---> good practice to ALWAYS ADD KEY 

            import React from 'react';
            import VideoListItem from './video_list_item';

            const Videolist = (props) => {

                const videoItems = props.videos.map((video) => {
                    // here we add the key as unique identifier (see comments below)
                    return <VideoListItem key={video.etag} video={video} />
                });

                const videos = props.video;
                // ERROR --  Each child in an array or iterator should have a unique "key" prop
                // React has logic built in for logic for rendering lists BUT NEEDS UNIQUE HANDLERS
                // SO IT KNOWS WHICH ITEMS IN LIST TO UPDATE --- use id's so React knows which components to update
                // COMMON STRATEGY -- use id for each piece of data
                // each video has an 'etag' which is unique identifier
                return (
                    <ul className="col-md-4 list-group">
                        {videoItems}
                    </ul>
                );
            };

            export default Videolist;
===============================================================================

BUILDING UP LIST ITEMS, USING PROPS

        video_list_item:

            import React from 'react';

            // const VideoListItem = (props) => {
            //     const video = props.video;
            //     return <li>Video</li>
            // }

            //ES6 syntax sugar below (does same as above)
            const VideoListItem = ({video}) => {
                // this argument above says --props being passed in has a video property, lets use that

                const imageUrl = video.snippet.thumbnails.default.url;

                // use CURLY BRACES to access JS variable inside JSX
                return (
                    <li className="list-group-item">
                        <div className="video-list media">
                            <div className="media-left">
                                <img className="media-object" src={imageUrl} alt=""/>
                            </div>

                            <div className="media-body">
                                <div className="media-heading">{video.snippet.title}</div>
                            </div>    
                        </div>
                    </li>
                );
            };

            export default VideoListItem;
===============================================================================

BUILDING NEW COMPONENTS AND WAITING FOR DATA:

    ---> ALWAYS ask yourself, do I expect this component to need to maintain any type of state
    ---> the video_detail component will only need video title, descript, and url ---> all passed
    in from props DONT REALLY NEED ANY STATE ---> use functional component


        index.js:

            import React, { Component } from 'react';
            import ReactDOM from 'react-dom';
            import YTSearch from 'youtube-api-search';
            import SearchBar from './components/search_bar';
            import VideoList from './components/video_list';
            import VideoDetail from './components/video_detail';
            const API_KEY = "AIzaSyBsX85XkZym24Kioz9iqQXmSG2ktLtTBdY";

            class App extends Component {
                constructor(props) {
                    super(props)

                    this.state = { videos: [] };

                    YTSearch({key: API_KEY, term: "surfboards"}, (videos) => {
                        this.setState({ videos });
                    });
                }
                render() {
                    // VideoList component can iterate over the array of videos, but how will VideoDetail
                    // know which data to render??? ASYNC ERROR ---> rendering things before they come in
                    // REACT wants to RENDER STUFF IMMEDIATELY, some parent components can't get info fast
                    // enough for child components
                    // Inside of VideoDetail file, we will add a check 
                    return (
                        <div>
                            <SearchBar />
                            <VideoDetail video={this.state.videos[0]}/>
                            <VideoList videos={this.state.videos}/>   
                        </div>
                    );
                }
            }

            ReactDOM.render(<App />, document.querySelector('.container'));

    video_detail.js:

            import React from 'react';

            const VideoDetail = ({video}) => {

                // this will handle React rendering page before videos get loaded
                // return statement means none of the rest of the code will run --> avoid ERROR of id
                // of undefined
                if(!video){
                    // we don't want 10 million spinners (waiting signs) so one on a parent comp is good
                    return <div>Loading...</div>;
                }

                const videoId = video.id.videoId;
                const url = `https://www.youtube.com/embed/${videoId}`;

                return (
                    <div className="video-detail col-md-8">
                        <div className="embed-responsive embed-responsive-16by9">
                            <iframe className="embed-responsive-item" src={url} frameborder="0"></iframe>
                        </div>
                        <div className="details">
                            <div>{video.snippet.title}</div>
                            <div>{video.snippet.description}</div>
                        </div>
                    </div>
                )
            }

            export default VideoDetail
===============================================================================

ADDIGN SELECTED VIDEO FEATURE AND PASSING IT TO DATA TO VIDEO DETAILS
===============================================================================

CHANGING PARENT STATE FROM CHILD COMPONENT (CHILD TO PARENT COMMUNICATION)

--> BASICALLY, CHILDREN COMPONENTS NEED TO CHANGE THE PARENT STATE, BUT THEY ARE CLASSES AND DON'T
HAVE ACCESS TO THIS.STATE
---> SO THE PARENT MUST PASS DOWN A FUNCTION TO THE CHILD COMPONENT, SO IT HAS A HANDLE WITH WHICH
TO CHANGE THE PARENT STATE WITH

---> Child-to-parent communication is a little more complicated. The standard way of doing this is to 
have the parent pass a function to the child through props. The child then calls this function at some 
point and passes it a value that the parent is supposed to react to. We then write the functionality 
for the parent's reaction inside the parent component.

    index.js:
            import React, { Component } from 'react';
            import ReactDOM from 'react-dom';
            import YTSearch from 'youtube-api-search';
            import SearchBar from './components/search_bar';
            import VideoList from './components/video_list';
            import VideoDetail from './components/video_detail';
            const API_KEY = "AIzaSyBsX85XkZym24Kioz9iqQXmSG2ktLtTBdY";

            class App extends Component {
                constructor(props) {
                    super(props)

                    // We'll add selected video to state, and start it off as null
                    this.state = { 
                        videos: [],
                        selectedVideo: null
                    };

                    YTSearch({key: API_KEY, term: "surfboards"}, (videos) => {
                        // adding selected video, will be video object and always passed into VideoDetail
                        // to update selected video we'll pass a CALLBACK from APP to VIDEOLIST and then 
                        // from VideoList into VideoListItem
                        // whenever VideoListItem is clicked it will run the callback with video that belongs to it

                        this.setState({ 
                            videos: videos,
                            selectedVideo: videos[0]
                        });
                    });
                }
                render() {
                    // Adding a CALLBACK TO VIDEOLIST, it will setState on App
                    // HERE WE PASS DOWN A SETSTATE FUNCTION TO VIDEOLIST WHICH HANDS IT TO
                    //VIDEOLISTITEM. SO WHEN VIDEOLISTITEM GETS CLICKED, IT CAN CHANGE THE
                    //PARENT STATE 'SELECTEDVIDEO' TO THE VIDEO OBJ THAT GOT CLICKED
                    return (
                        <div>
                            <SearchBar />
                            <VideoDetail video={this.state.selectedVideo}/>
                            <VideoList 
                                onVideoSelect={selectedVideo => this.setState({selectedVideo}) }
                                videos={this.state.videos}
                            />   
                        </div>
                    );
                }
            }

            ReactDOM.render(<App />, document.querySelector('.container'));

    video_list.js:

            import React from 'react';
            import VideoListItem from './video_list_item';

            const Videolist = (props) => {

                const videoItems = props.videos.map((video) => {
                    // Here we will take the prop coming from VideoList (in App component) and 
                    // passing it down to VideoListItem (which will know what video gets clicked)
                    return (
                        <VideoListItem
                            onVideoSelect={props.onVideoSelect}
                            key={video.etag} 
                            video={video} 
                        />
                    )
                });

    video_list_item.js:

            import React from 'react';

            // So now VideoList Item has access to onVideoSelect:
            const VideoListItem = ({video, onVideoSelect}) => {

                const imageUrl = video.snippet.thumbnails.default.url;
                // ADDING ONCLICK FUNCTIONALITY TO PASS CLICKED VIDEO UP TO THE PARENT'S STATE
                return (
                    <li className="list-group-item" onClick={ () => onVideoSelect(video) }>
                        <div className="video-list media">
                            <div className="media-left">
                                <img className="media-object" src={imageUrl} alt=""/>
                            </div>

                            <div className="media-body">
                                <div className="media-heading">{video.snippet.title}</div>
                            </div>    
                        </div>
                    </li>
                );
            };

            export default VideoListItem;
===============================================================================

MAKING SEARCHBAR WORK (MORE CHILD TO PARENT COMMUNICATION)

---> adding function to App class, then handing it down

        index.js:
            import React, { Component } from 'react';
            import ReactDOM from 'react-dom';
            import YTSearch from 'youtube-api-search';
            import SearchBar from './components/search_bar';
            import VideoList from './components/video_list';
            import VideoDetail from './components/video_detail';
            const API_KEY = "AIzaSyBsX85XkZym24Kioz9iqQXmSG2ktLtTBdY";

            class App extends Component {
                constructor(props) {
                    super(props)

                    this.state = { 
                        videos: [],
                        selectedVideo: null
                    };
                    // TOOK out YTSearch, but we still want constructor to initialize a search
                    this.videoSearch('surfboards');
                }
                
                // Defining NEW CALLBACK for new video searches to pass down in render
                videoSearch(term) {
                    YTSearch({key: API_KEY, term: term}, (videos) => {
                        this.setState({ 
                            videos: videos,
                            selectedVideo: videos[0]
                        });
                    });
                }

                render() {
                    return (
                        <div>
                            <SearchBar onSearchTermChange={term => this.videoSearch(term)} />
                            <VideoDetail video={this.state.selectedVideo}/>
                            <VideoList 
                                onVideoSelect={selectedVideo => this.setState({selectedVideo}) }
                                videos={this.state.videos}
                            />   
                        </div>
                    );
                }
            }

            ReactDOM.render(<App />, document.querySelector('.container'));


        search_bar.js:
            import React, { Component} from 'react';

            class SearchBar extends Component {
                constructor(props){
                    super(props);

                    this.state = { term: "" };
                }

                render() {
                    return(
                        <div className="search-bar">
                            <input 
                                value = {this.state.term}
                                onChange={event => this.onInputChange(event.target.value)} />
                        </div>
                    );
                }
                // Adding a method down here to reference THIS.PROPS.onSearchTermChange and
                // pass it the term
                onInputChange(term) {
                    this.setState({term});
                    this.props.onSearchTermChange(term);
                }
            }

            export default SearchBar;
===============================================================================


===============================================================================
===============================================================================
===============================================================================

REDUX

--> predictable state container for JS applications

--> There is no intrinsic connection between React and Redux, need a library just to join the two
called React-Redux

--> A collection of all the data relates to the app --> List of videos, which video is selected
--> ALl data is centralized into a central single object, THE STATE

--> Design a COMPONENT AS A CONTAINER
===============================================================================

CONTAINER 
--> git is a React component that has direct connection to the state managed by Redux

    book_list.js

            import React, {Component} from 'react';
            import { connect } from 'react-redux';
            import { selectBook } from '../actions/index';

            class BookList extends Component {
                renderList() {
                    return this.props.books.map((book) => {
                        return (
                            <li key={book.title} className="list-group-item">{book.title} </li>
                        )
                    })
                }

                render() {
                    return (
                        <ul className="list-group col-sm-4">
                            {this.renderList()}
                        </ul>
                    )
                }
            }

                // mapStateToProps is what connects React to Redux
                // whenever application state changes, this 
                // container (BookList) will rerender
            function mapStateToProps(state) {
                // Whatever is returned will show up as props insed BookList
                return {
                    books: state.books
                };
            }

                // HERE WE USE CONNECT FUNCTION WE IMPORTED
                // connect is what says "take this component, take this 
                // mapStateToProps" and RETURN A CONTAINER
                // whenever we make a container we don't want to export 
                // BookList class,
                // we want to export the container
            export default connect(mapStateToProps)(BookList);
                // connect takes a function and a component and
                // produces a container
                // container => a component that is aware of the state that is
                // contained by redux

                // MapStateToProps => returns an object which is available as
                // this.state.props

===============================================================================

REDUCERS

--> A reducer is a function that returns a piece of an applications state
--> An app can have many pieces of state, so the same amount of reducers
===============================================================================

ACTIONS AND ACTION CREATORS

--> These are for changing State

--> Everything in a Redux application starts with an event created by user
    ---> user clicks something, hovering on element, or indirect like AJAX request finishing

--> These events call an ACTION CREATOR --> function that returns an action
--> ACTION CREATOR is a function that RETURNS AN OBJECT

--> this object is then sent automatically to all the different reducers in App

-->reducers can CHOOSE TO RETURN A DIFFERENT PIECE OF STATE

--> this newly returned piece of state gets piped to the application state

--> finally, the new application state gets pumped back into React Application
causing all the components to re-render

--> action creator has a "TYPE" that describes the type of action that was just triggered
also has data that describes action

--> THE OBJECT RETURNED BY ACTION CREATOR IS THE ACTUAL ACTION

--> Reducers have a switch statement to receive ACTION, switch statement decides response
to action depending on what action is

--> Reducers return either 1) same state 2) change piece of state to global state

--> When all reducers process action, new assembled STATE gets pumped back to all different
containers --> All diff containers will run func mapStateToProps --> new State will be dissected
---> all the containers will re-render with all their data


FLOWWWW:

----> First thing when app starts up, STATE is set by Redux reducers, index imports
all reducers and sets GLOBAL STATE:

        index.js (reducers):

            import { combineReducers } from 'redux';
            import BooksReducer from './reducer_books';
            import ActiveBook from './reducer_active_book';

            const rootReducer = combineReducers({
                books: BooksReducer,
                activeBook: ActiveBook
            });

            export default rootReducer;

---> So index goes through these other reducers to see what to set to GLOBAL STATE
---> In this case, there is no action (nothing has happened yet) so state of 
state (globally speaking -> state.book) is set to NULL

        reducer_active_book.js:

            // all reducers get two arguments, current state and action
            // State argument is not application state, only the state this
            // reducer is responsible for

            // state = null --> if state is undefined, it's set to null
            // redux throws error if it returns "undefined"
            export default function(state = null, action) {
                switch(action.type) {
                    case "BOOK_SELECTED":
                        return action.payload;
                }
                
                return state;
            }

---> So at this point, state.books has a collection of books, state.book is null
---> Now React goes to Render our App component, which tells it to render our
<Booklist /> and <BookDetail />
---> Book List returns JSX for the book collection
---> BookDetail goes to book-detail below...

        app.js:

            import React, { Component } from 'react';

            import BookList from '../containers/book-list';
            import BookDetail from '../containers/book-detail'

            export default class App extends Component {
            render() {
                return (
                <div>
                    <BookList />
                    <BookDetail />
                </div>
                );
            }
            }
    
---> React is now trying to render BookDetail from this file, but it already went to
reducer_active_book.js and figured out its null because no actions yet
---> We catch the this.props.book is null and render a message to get started

        /containers/book-detail.js:

            import React, { Component } from 'react';
            import { connect } from 'react-redux';

            // include conditional because state of activeBook is null until something is clicked
            // without this, it will ERROR at this.props.book.title (null)

            //BookDetail is now a CONTAINER with its mapStateToProps function which
            // sets a property "book" to Redux State, (BookList added property "books")
            // so book is active selected book, and books is entire collection
            class BookDetail extends Component {
                render(){
                    if(!this.props.book){
                        return <div>Select a book to get started</div>;
                    }

                    return (
                        <div>
                            <h3>Details for:</h3>
                            <div>{this.props.book.title}</div>
                        </div>
                    );
                }
            }

            function mapStateToProps(state) {
                return {
                    book: state.activeBook
                };
            }

            export default connect(mapStateToProps)(BookDetail);

---> Now when a book gets clicked on in our <BookList />, the onClick handler fires off
this.props.selectBook ---> which was imported (import { selectBook } from '../actions/index';)
---> selectBook is the ACTION CREATOR which we made with:
    function mapDispatchToProps(dispatch) and then the connect function
---> onClick handler gives out the specific book information which was clicked (book)
---> so the onClick handler fires a dispatch, running THE ACTION CREATORS


        /containers/book-list.js:

            import React, {Component} from 'react';
            import { connect } from 'react-redux';
            import { selectBook } from '../actions/index';

            // bindActionCreators is what we use to make sure ACTION created by ACTION CREATOR
            // actually ends up flowing through all different reducers
            import { bindActionCreators } from 'redux';

            class BookList extends Component {
                renderList() {
                    return this.props.books.map((book) => {
                        // down here we add a click handler to run this.props.selectBook and pass
                        // the particular book that was clicked
                        return (
                            <li 
                                key={book.title}
                                onClick={() => this.props.selectBook(book)}
                                className="list-group-item">
                                {book.title} 
                            </li>
                        )
                    })
                }

                render() {
                    return (
                        <ul className="list-group col-sm-4">
                            {this.renderList()}
                        </ul>
                    )
                }
            }

            function mapStateToProps(state) {
                return {
                    books: state.books
                };
            }
            // this CALLS ACTION CREATOR --> selectBook and SENDS ACTION TO ALL REDUCERS
            // Anything returned from this function will end up as PROPS on BookList CONTAINER

            function mapDispatchToProps(dispatch) {
                // selectBook value is the function we imported at top of file
                // whenever selectBook is called the result should be passed to all reducers
                // ---> thats what ActionCreators is doing with DISPATCH --> sends to all reducers

                return bindActionCreators({ selectBook: selectBook}, dispatch);

                // so now on our container we can call this.props.selectBook and it 
                // will call our ACTION CREATOR
            }

            // Down here we add another argument
            // Promote book list from a component to container, it needs to know about
            // this dispatch method SelectBook. Make it available as a prop
            export default connect(mapStateToProps, mapDispatchToProps)(BookList);


---> ACTION CREATOR for selectBook is run, it returns a NEW ACTION
---> the NEW ACTION IS AUTOMATICALLY SENT TO ALL REDUCERS

        /actions/index.js:

            export function selectBook(book) {
                // SelectBook is an ACTIONCREATOR NEEDS TO RETURN AN ACTION
                // ACTION IS OBJECT WITH TYPE PROPERTY AND PAYLOAD
                return {
                    type: "BOOK_SELECTED",
                    payload: book
                };
            }

---> The reducer waiting for action.type = "BOOK_SELECTED" is run, and the type satisfies
switch case statement
---> So we RETURN THE NEW STATE OF state.book (state.payload)

        /reducers/reducer_active_book.js:

            export default function(state = null, action) {
                switch(action.type) {
                    case "BOOK_SELECTED":
                        return action.payload;
                }

                return state;
            }

---> Reducers go to get processed in rootReducer
---> ActiveBook is imported in rootReducer, and passes selected book into global state

        /reducers/index.js:

            import { combineReducers } from 'redux';
            import BooksReducer from './reducer_books';
            import ActiveBook from './reducer_active_book';

            const rootReducer = combineReducers({
                books: BooksReducer,
                activeBook: ActiveBook
            });

            export default rootReducer;

---> New state is assembled by rootReducer, so React CONTAINER of book-detail.js updates
---> Since this.props.book exists now, React render the book that was clicked

        /containers/book-detail.js:

            import React, { Component } from 'react';
            import { connect } from 'react-redux';

            //BookDetail is now a CONTAINER with its mapStateToProps function which
            // sets a property "book" to Redux State, (BookList added property "books")
            // so book is active selected book, and books is entire collection
            class BookDetail extends Component {
                render(){
                    if(!this.props.book){
                        return <div>Select a book to get started</div>;
                    }

                    return (
                        <div>
                            <h3>Details for:</h3>
                            <div>{this.props.book.title}</div>
                        </div>
                    );
                }
            }

            function mapStateToProps(state) {
                return {
                    book: state.activeBook
                };
            }

            export default connect(mapStateToProps)(BookDetail);


===============================================================================
===============================================================================
===============================================================================

MIDDLEWARE

--> All actions run through a middleware stage, and middlewares can modify actions

---> Middle ware are like doormen, or bouncers, that act between the ACTION CREATOR and
reducer. They inspect and act upon the ACTION, and let it through, return something else,
or don't let it through

---> can have 1, 0, or 1000000 middlewares before action hits the reducer
    setup

        conatiners/search_bar.js

            import React, { Component } from 'react';

            export default class SearchBar extends Component {
                // TO MAKE CONTROLLED FIELD
                // 1 make state -- add constructor and initial state obj
                // 2 add event handler on input
                // 3 define event handler in class
                constructor(props) {
                    super(props);

                    this.state = { term: "" };

                    //  when calling onInputChange, it will ERROR unless 'this' is bound to it
                    // because 'this' will be watever object calls onInputChange instead of
                    // the state object.

                    // So this says , GRAB THIS CLASS'S ONINPUTCHANGE, BIND IT WITH THIS (POINTING
                    // BACK TO CLASS), AND THEN REPLACE THE CURRENT ONINPUT CHANGE DEFINED IN
                    // CLASS
                    this.onInputChange = this.onInputChange.bind(this)
                }

                onInputChange(event) {
                    console.log(event.target.value);
                    this.setState({term: event.target.value})
                }

                onFormSubmit(event) {
                    event.preventDefault();
                }

                render() {
                    // A controlled field is a form element where the value of the input is set
                    // by the state of the component. State will be the input, need to change 
                    // component state with every input
                    return (
                        <form onSubmit={this.onFormSubmit} className="input-group"> 
                            <input 
                                placeholder="Get a five-day forecast in your favorite cities"
                                className="form-control"
                                value={this.state.term}
                                onChange={this.onInputChange}
                            />
                            <span className="input-group-btn">
                                <button type="submit" className="btn btn-secondary">Submit</button>
                            </span>
                        </form>
                    )
                }
            }

===============================================================================